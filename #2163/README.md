# __:bulb: [BOJ #2163번] (초콜릿 자르기) 문제 풀이__

### :link: [[소스 코드]](https://github.com/seungrokoh/Beakjoon_OnlineJudge/blob/master/%232163/2163.java)
***

##### __:seedling: 문제 해결 방식__

이 문제는 __정말 쉽게 해결__ 할 수 있는 방법과 __DP로 접근하여__ 푸는 방법 총 2가지가 있습니다.. 먼저 첫 번째 방법에 대해서 살펴보겠습니다..

먼저 문제에 조건을 확인해보면, 초콜릿을 자르는데 정확히 __금이 가있는 곳을__ 자르면 __두 개의__ 조각이 생기는데 이 중 __한 개의 조각을__ 다시 들고 자르는 행동을 반복합니다. 두 개의 조각을 겹쳐서 자를 수 없기 때문에 __결국 금이 가있는 모든 곳을 자르는 행동을__ 해야만 합니다. 결국 `N * M - 1`이라는 식이 도출이 됩니다. __그림을 그려보면 쉽게 이해할 수 있습니다.__ 이 문제가 DP문제 이지만 정답률이 높은 이유가 이것 때문인 것 같습니다.

두 번째 방법은 DP로 접근하는 방식입니다. 문제의 조건은 조각을 잘라 `1 * 1 조각`을 만드는 최소의 비용입니다. 따라서 __base case는 N과 M이 1일 때__ 입니다. 그리고 이제 초콜릿을 나눠야 하는데 저는 다음과 같은 생각을 하였습니다. __초콜릿의 모양이 N 이나 M 이 1인 경우, 즉 N * 1모양이면 M 방향으로 계속해서 나누며 M * 1 모양은 반대이다.__ 즉, 1일 쪽은 더이상 나눌 수 없다는 뜻입니다. 문제를 해결할 때 N 또는 M에 대해서 한쪽만 생각하면 되기 때문에 다음과 같이 문제를 해결 할 수 있습니다.

##### __dp 소스코드__
```java
static int solve(int row, int col) {
    // 1 * 1 조각일 경우
    if (row == 1 && col == 1) return 0;
    // 이미 구해진 값
    if (dp[row][col] != 0) return dp[row][col];

    // N * 1 모양일 경우
    if (col == 1) return dp[row][col] = solve(row / 2, col) + solve(row - row / 2, col) + 1;

    return dp[row][col] = solve(row, col / 2) + solve(row, col - col / 2) + 1;
}
```

초콜릿을 반으로 나누었을 때 __짝수일 경우와 홀수일 경우가 있는데__ 이를 if 분기로 하지 않고 __solve(row / 2, col) + solve(row - row / 2, col)__ 식으로 타나 내었습니다. 한 조각을 나누면 총 2개의 조각이 생기는걸 더해야 결괏값을 낼 수 있습니다.




##### :seedling: Top-Down 과 Bottom-Up
    * Top-Down 방식 : 가독성이 좋으며 본래 점화식을 이해하기 쉽다.
    * Bottom-Up 방식 : 함수를 별개로 부르지 않아 시간과 메모리를 소량 더 절약할 수 있다.
