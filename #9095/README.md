# __:bulb: [BOJ #9095번] (1, 2, 3 더하기) 문제 풀이__

### :link: [[소스 코드]](https://github.com/seungrokoh/Beakjoon_OnlineJudge/blob/master/%239095/9095.java)
***

문제에서 친절하게도 n이 4일때 까지의 답을 알려줬습니다. 먼저 문제를 접근하는 방법에 대해서 알아보도록 하죠.  

어떤 수를 1,2,3으로 만드는 방법의 수를 나타내는 것을 `f(n)`이라고 정의해봅시다. 먼저 `f(4)`까지 경우의 수를 나열해 보겠습니다.

##### __:seedling: f(4)까지 나열해보기__
    1. f(1)
        -> 1
    2. f(2)
        ->  1 + 1
            2
    3. f(3)
        ->  1 + 1 + 1
            1 + 2
            2 + 1
            3
    4. f(4)
        ->  1 + 1 + 1 + 1
            1 + 2 + 1
            2 + 1 + 1
            3 + 1

            1 + 1 + 2
            2 + 2

            1 + 3

가능한 경우의 수를 모두 나열했는데 여기서 `주의 깊게 봐야 할 점`은 `f(4)`에 있습니다. 제가 일부러 `공백을 주어 case에 따라` 나누어 놨습니다. 자세히 살펴보면 f(4)의 경우의 수는 `f(3)에 숫자 1을 더한 수` + `f(2)에 숫자 2를 더한 수` + `f(1)에 숫자 1을 더한 수`입니다.

조금 더 쉽게 이해하자면 `f(3)`은 이미 3을 만들 수 있는 경우의 수 입니다. 여기서 `숫자 4`를 만들기 위해선 `f(3)의 경우의 수` 뒤에 + 1을 붙이는 방법 밖에 없습니다. `+ 2를 붙이면 5가 되어버리죠`. 즉 아래와 같이 표시하며 점화식도 세울 수 있습니다.

    f(4) =  f(3)의 경우의 수 뒤에 + 1을 붙인 수
            f(2)의 경우의 수 뒤에 + 2를 붙인 수
            f(1)의 경우의 수 뒤에 + 3을 붙인 수

    f(5) =  f(4)의 경우의 수 뒤에 + 1을 붙인 수
            f(3)의 경우의 수 뒤에 + 2를 붙인 수
            f(2)의 경우의 수 뒤에 + 3을 붙인 수

결국 `f(n)`을 1,2,3의 합으로 나타내는 점화식은 아래와 같습니다.

> f(n) = f(n-1) + f(n-2) + f(n-3)

코드로 나타내면 다음과 같습니다.

##### __:seedling: 재귀 소스코드__
```java
private static int solve(int n) {
    // 이미 구한 값이라면 리턴
    if (dp[n] != 0) return dp[n];

    // n이 1,2,3일때 값
    if (n == 1) return dp[n] = 1;
    if (n == 2) return dp[n] = 2;
    if (n == 3) return dp[n] = 4;

    return dp[n] = solve(n - 1) + solve(n - 2) + solve(n - 3);
}
```
